;;; -*- mode: emacs-lisp; -*-

;;; .emacs - configuration file for emacs
;;; Author: Cameron Desautels

;; Load up personal elisp files (those not in global path)
(add-to-list 'load-path (expand-file-name "~/.elisp"))
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")

;;; MY COMMANDS

;; Escape all double-quotes (") in the region
(fset 'escape-region-double-quotes
   "\C-xnn\C-[<\C-[%\"\C-m\\\"\C-m!\C-[>\C-xnw")

;; Should make this uncomment if the line is already commented. Or at
;; least do so when an argument is given.
(defun comment-line ()
  "Comments out the line containing point."
  (interactive)
  (save-excursion
    (beginning-of-line)
;;    (if (looking-at "^[ \t]* ; this would only work in a mode-specific way
    (let ((beg (point)))
      (end-of-line)
      (let ((end (point)))
        (comment-region beg end)))))

(defgroup genfoc nil
  "Display randomly generated strings."
  :group 'data)

(defcustom genfoc-location "~/src/my/focus-gen/genfoc"
  "*Location of genfoc executable for displaying random ideas."
  :group 'genfoc
  :type 'string)

(defcustom genfoc-data-file "~/src/my/focus-gen/main.gfd"
  "*Location of main data file for genfoc."
  :group 'genfoc
  :type 'string)

(defun get-genfoc (&optional data-file)
  "Returns an idea, randomly generated by genfoc from the data-file DATA-FILE.\
  Uses default data-file if one is not given."
  (shell-command-to-string
   (concat genfoc-location " < " (or data-file genfoc-data-file) "&")))

(defun display-genfoc ()
  "Displays a randomly generated computer game idea."
  (interactive)
  (message (get-genfoc)))

(defun display-ad-genfoc ()
  "Displays a randomly generated idea from an alternate datafile."
  (interactive)
  (message (get-genfoc "~/src/my/focus-gen/ad.gfd")))

(defun insert-genfoc-at-point ()
  "Inserts a randomly generated computer game idea at point."
  (interactive)
  (insert (get-genfoc)))


(defun count-words-buffer ()
  "Count the number of words in the current buffer and print the
result in the minibuffer."
  (interactive)
  (count-words-region (point-min) (point-max)))

(defun count-words-region (region-start region-end)
  "Count the number of words in the region and print the result in the
minibuffer"
  (interactive "r")
  (save-excursion
    (save-restriction
      (widen)
      (let ((count 0))
        (goto-char region-start)
        (while (< (point) region-end)
          (forward-word 1)
          (setq count (1+ count)))
        (message "Contains %d words." count)))))

(defun count-words-buffer-using-wc nil "Count words in buffer" (interactive)
  (shell-command-on-region (point-min) (point-max) "wc -w"))

(defun kill-entire-line ()
  "Kills a line from beginning to end, including the following newline
character."
  (interactive)
  (beginning-of-line)
  (kill-line
   (unless (looking-at "$")
     1)))

(defun duplicate-line ()
  "Duplicate the current line."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (push-mark (point))
    (end-of-line)
    (copy-region-as-kill)
    (newline)
    (yank)))

(defun outline-increase-region-depth (region-start region-end &optional depth)
  "Increase the depth of header lines in region by DEPTH.
  If no DEPTH is given, defaults to 1."
  (interactive "r\np")
  (save-excursion
    (let ((indent-string (make-string depth ?*)))
      (goto-char region-start)
      (beginning-of-line)
      (while (< (point) region-end)
        (if (looking-at "\*")
            (insert indent-string))
        (forward-line)))))

(defun outline-newline-and-indent (&optional p)
  "Inserts a newline and a new header at the current outline level.
With a prefix, makes a new header at the parent level."
  (interactive "P")
  (let ((current-pos (point)))
    ;; if we were able to go up the outline
    (unless (condition-case nil
                (outline-up-heading 1) ; this func. always returns nil
              (error t))            ; so we make it return t on error
        ; then: we are not at the top level
      (let ((up-level-prefix
             (buffer-substring-no-properties
              (progn
                (beginning-of-line)
                (point))
              (progn
                (forward-word 1)  ; leave point just 
                (backward-word 1) ;  before 1st word
                (point)))))
        (goto-char current-pos)
        (newline)
        (insert up-level-prefix))
      ;; else: we were at the top level
      (progn
        (goto-char current-pos)
        (newline)
        (insert ? ))))
  (beginning-of-line)
  (unless p
    (insert ?*))
  (end-of-line))

(add-hook 'outline-mode-hook
          '(lambda ()
             (define-key outline-mode-map "\C-j"
               'outline-newline-and-indent)))

(defun insert-c-for-loop (variable max)
  "Inserts a C-style for loop in which the given VARIABLE is \
incremented from 0 to MAX."
  (interactive "sVariable name for for loop:\nnValue to increment \
to:")
  (beginning-of-line)
  (c-indent-line)
  (insert (format "for (int %s = 0; %s < %d; %s++)"
                  variable variable max variable))
  (newline-and-indent)
  (insert "{\n\n}")
  (c-indent-line)
  (forward-line -1)                   ; go back a line
  (c-indent-line))

(defun reread-config-file ()
  "Reread .emacs file"
  (interactive)
  (load-file "~/.emacs"))

(defun kill-buffer-other-window ()
  "Kill the buffer currently displayed in the other window."
  (interactive)
  (other-window 1)
  (kill-buffer nil)
  (other-window 1))

(defun delete-window-replacement (&optional p)
  "Kill current window.  If called with PREFIX, kill the buffer too."
  (interactive "P")
  (if p
      (kill-buffer nil))
  (delete-window))

(defun delete-other-windows-replacement (&optional p)
  "Make the selected window fill its frame.  If called with PREFIX,
kill all other visible buffers."
  (interactive "P")
  (if p
      (dolist (window (window-list))
        (unless (equal (window-buffer window) (current-buffer))
          (kill-buffer (window-buffer window)))))
  (delete-other-windows))

(defun buffer-file-basename (buf)
  "Return the filename, with extension removed, of the file associated
with the buffer `buf'.  Returns nil if there is no file associated
with `buf'."
  (let ((filename (buffer-file-name buf)))
    (if filename
        (file-name-nondirectory (file-name-sans-extension filename)))))

(defun buffers-same-file-basename (buf)
  "Return the list of buffers which are associated with files with the
same basename (filename sans extension) as the file the buffer `buf'
is associated with."
  (let ((basename (buffer-file-basename buf)))
    (remove nil
            (mapcar #'(lambda (obuf)
                        (unless
                            (or (eq buf obuf)
                                (not (string= basename (buffer-file-basename obuf))))
                          obuf))
                    (buffer-list)))))

(defun next-buffer-same-file-basename ()
  "Switch to the next buffer (if one exists) associated with a file of
the same basename (filename sans extension) as the ile the current
buffer is associated with."
  (interactive)
  (let ((next-buffer (car (buffers-same-file-basename (current-buffer)))))
    (if next-buffer
        (switch-to-buffer next-buffer)
      (message "No buffers exist with same file basename"))))

;; SKELETONS

(define-skeleton blog-entry-skeleton
  "Inserts a PyBlosxom-style blog entry skeleton into the current buffer.
This only makes sense for empty buffers."
  "Title: "
  str | "Untitled Entry" \n
  "#postdate " (insert-date-and-time) \n
  "#tags " ("Enter a tag: " str ",") '(delete-backward-char 1) \n \n
  "<p>" _ "</p>")

(define-skeleton c-c++-header-skeleton
  "Inserts a skeleton for C and C++ header files in the format I like."
  (upcase
   (concat
    "__"
    (replace-regexp-in-string "\\." "_" (upcase (file-name-nondirectory buffer-file-name)))
    "__"))
  "#ifndef " str n "#define " str "\n\n" _ "\n\n#endif /*" str "*/")

(eval-after-load "autoinsert"
  '(progn
     (add-to-list 'auto-insert-alist '("\\.blog\\'" . blog-entry-skeleton))
     (add-to-list 'auto-insert-alist
                  '("\\.\\([Hh]\\|hh\\|hpp\\)\\'" . c-c++-header-skeleton))))


;; OPTIONS AND CONFIGURATION

(require 'genfoc-mode nil t)

;; Set up mail
(require 'smtpmail)
(setq smtpmail-smtp-server "smtp.comcast.net")
(setq smtpmail-local-domain "")
(setq send-mail-function 'smtpmail-send-it)

;; Set up xtla (Arch browser) (C-x T C-h for more info)
(require 'xtla nil t)

(setq user-mail-address "")
(setq user-full-name "Cameron Desautels")

(setq inhibit-startup-message t)
(setq visible-bell t)
(blink-cursor-mode -1)                  ; make the bloody cursor stop blinking
(setq-default indent-tabs-mode nil)     ; use spaces (not tabs) for indenting
(setq kill-ring-max 10)                 ; don't save too many kills (I don't use many)
(setq require-final-newline t)          ; always terminate last line in file
(setq default-major-mode 'text-mode)    ; default mode is text mode

(global-font-lock-mode t)               ; use syntax highlighting
(show-paren-mode t)                     ; highlight matching parentheses
(setq blink-matching-paren nil)
;; Make matching paren red on a black background
(custom-set-faces
 '(show-paren-match-face ((((class color)) (:background "black" :foreground "red")))))

(setq tab-width 2)

(which-func-mode t)                     ; show current function in modeline
(setq display-time-day-and-date t)      ; display day and date
(display-time)                          ; display the time

(setq frame-title-format "Emacs: %b %+%+ %f")
(setq ange-ftp-ftp-program-name "netkit-ftp")

(c-set-style "gnu")                     ; set the c-indentation style to GNU style

(mouse-wheel-mode 1)                    ; make the mouse wheel work
(auto-image-file-mode 1)                ; open images as images
(auto-compression-mode 1)               ; automagically explore compressed files when visited
(menu-bar-mode -1)                      ; hide the menu bar
(tool-bar-mode -1)                      ; hide the tool bar
(scroll-bar-mode -1)            ; put the scroll bar on the right where it should be

;; Enable disabled operations
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)

;; Disable annoying operations
(put 'overwrite-mode 'disabled t)

;; open files in desirable modes...
(add-to-list 'auto-mode-alist '("\\.uc\\'" . java-mode)) ; open UnrealScript files as java
(add-to-list 'auto-mode-alist '("\\.gfd\\'" . genfoc-mode))
(add-to-list 'auto-mode-alist '("\\.cs\\'" . java-mode))
(add-to-list 'auto-mode-alist '("mutt-.*-[0-9]+-[0-9]+-[0-9]+\\'" . post-mode))
(add-to-list 'auto-mode-alist '("\\.blog\\'" . html-mode))

;; Be smart and don't display my passwords in shell mode...
(add-hook 'comint-output-filter-functions
          'comint-watch-for-password-prompt)

;; Start up text mode with auto-fill on
(add-hook 'text-mode-hook 'turn-on-auto-fill)

;; Autoinsert text into empty files where defined
(add-hook 'find-file-hooks 'auto-insert)

;; Automagically turn on eldoc mode for emacs-lisp buffers
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)

;; Use awesome buffer switching mode
(if (> emacs-major-version 21)
    (iswitchb-mode 1)
  (iswitchb-default-keybindings))

;;; KEYBINDINGS
(global-set-key [f2] 'goto-line)
(global-set-key [f3] (lambda ()
                       (interactive)
                       (switch-to-buffer (other-buffer))))
(global-set-key [f5] 'display-genfoc)
(global-set-key [f8] 'eshell)
(global-set-key [f9] 'speedbar)
; If running under X, have [f10] toggle display of menu-bar (and
; tool-bar) instead of running tmm-menubar.  Don't toggle one off and
; one on.
(if window-system
    (global-set-key [f10] (lambda ()
                            (interactive)
                            (if (eq menu-bar-mode tool-bar-mode)
                                (progn
                                  (menu-bar-mode nil)
                                  (tool-bar-mode))
                              (menu-bar-mode nil)))))
(global-set-key [f11] 'compile)
(global-set-key [f12] 'recompile)
(global-set-key [del] 'delete-char)
(global-set-key "\C-x0" 'delete-window-replacement)
(global-set-key "\C-x1" 'delete-other-windows-replacement)
(global-set-key "\C-x4k" 'kill-buffer-other-window)
(global-set-key [C-right] 'next-buffer)
(global-set-key [C-left] 'prev-buffer)
(global-set-key [C-up] 'next-buffer-same-file-basename)
; This practially makes the previous line useless, but the differences
; should be investigated.
(global-set-key "\M-`" 'ff-find-other-file)

(global-set-key "\C-cf" 'auto-fill-mode)
(global-set-key "\C-cl" 'goto-line)
(global-set-key "\C-ch" 'hl-line-mode)

(setq html-mode-hook
      '(lambda ()
         (auto-fill-mode 1)
         (define-key html-mode-map "\C-c\C-p" 'php-mode)))
(setq php-mode-hook
      '(lambda ()
         (define-key php-mode-map "\C-c\C-p" 'html-mode)))


;;; OTHER CRAP, GENERALLY WRITTEN BY OTHER PEOPLE
; Insert the date, the time, and the date and time at point. Insert the
; date 31 days hence at point (eventually...). Useful for keeping
; records. These are based on Glickstein.

(defvar insert-time-format "%T"
  "*Format for \\[insert-time] (c.f. 'format-time-string' for how to format).")

(defvar insert-date-format "%Y-%m-%d"
  "*Format for \\[insert-date] (c.f. 'format-time-string' for how to format).")

(defun insert-time ()
  "Insert the current time according to the variable \"insert-time-format\"."
  (interactive "*")
  (insert (format-time-string insert-time-format
			      (current-time))))

(defun insert-date ()
  "Insert the current date according to the variable \"insert-date-format\"."
  (interactive "*")
  (insert (format-time-string insert-date-format
			      (current-time))))

(defun insert-date-and-time ()
  "Insert the current date according to the variable \"insert-date-format\", then a space, then the current time according to the variable \"insert-time-format\"."
  (interactive "*")
  (progn
    (insert-date)
    (insert " ")
    (insert-time)))

(defun indent-or-complete ()
  "Complete if point is at end of a word, otherwise indent line."
  (interactive)
  (if (looking-at "\\>")
      (dabbrev-expand nil)
    (indent-for-tab-command)))

;; (add-hook 'c-mode-common-hook
;;           (function (lambda ()
;;                       (local-set-key (kbd "<tab>") 'indent-or-complete)
;;                       )))

;;(defun indent-or-complete ()
;;      "Complete if point is at end of line, and indent line."
;;      (interactive)
;;      (if (looking-at "$")
;;          (hippie-expand nil))
;;        (indent-for-tab-command))

(defun pretty-lambdas ()
  (font-lock-add-keywords
   nil `(("(\\(lambda\\>\\)"
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(make-char 'greek-iso8859-7 107))
                    nil))))))

;;; SITE-SPECIFIC CODE
(load "local" t)                        ;load anything site-specific

;;; END
