# -*- mode: sh; -*-

# .bashrc
# This file is sourced by bash to create the prompt

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

# Determine of this is an interactive shell and run dependent commands
case $- in
    *i*)
        # This is an interactive shell
        # XXX prompt command does nothing if __make_prompt not set
        # TODO maybe unset it on failure
        export PROMPT_COMMAND='type __make_prompt >/dev/null 2>/dev/null && __make_prompt'
        ;;
    *)
        # Do nothing as this is a non-interactive shell
        return
        ;;
esac

# Aliases
alias e='emacsclient'
#eval `dircolors -b`
#alias ls='ls --color=auto'
alias ls='ls -G'                              # colorize `ls` output (Mac version)
alias lsd='ls -F | grep \/ | sort'            # list only dirs, alphabetically
alias rmb='rm *~'                             # remove emacs backup files
alias rmbr="find . -name '*~' -exec rm {} \;" # recursive version of above
alias ssh='ssh -C'                            # enable compression

# Configure Colors:
export COLOR_WHITE='\033[1;37m'
export COLOR_LIGHTGRAY='033[0;37m'
export COLOR_GRAY='\033[1;30m'
export COLOR_BLACK='\033[0;30m'
export COLOR_RED='\033[0;31m'
export COLOR_LIGHTRED='\033[1;31m'
export COLOR_GREEN='\033[0;32m'
export COLOR_LIGHTGREEN='\033[1;32m'
export COLOR_BROWN='\033[0;33m'
export COLOR_YELLOW='\033[1;33m'
export COLOR_BLUE='\033[0;34m'
export COLOR_LIGHTBLUE='\033[1;34m'
export COLOR_PURPLE='\033[0;35m'
export COLOR_PINK='\033[1;35m'
export COLOR_CYAN='\033[0;36m'
export COLOR_LIGHTCYAN='\033[1;36m'
export COLOR_DEFAULT='\033[0m'

# Save these so we can check against them in later prompts
export __NORMAL_USER=$USER
export __NORMAL_HOST=$HOSTNAME

function __make_prompt() {
    # This has to come first
    local RET=$?

    local PROMPT_COLOR=$COLOR_GREEN

    if [ $RET -ne 0 ]; then
        local FACE_PART="${COLOR_RED}:(${COLOR_DEFAULT}\n"
    fi

    if [ $USER != $__NORMAL_USER ]; then
        local PROMPT_USER_PART='\u'
    fi

    if [ `hostname` != $__NORMAL_HOST ]; then
        local PROMPT_HOST_PART='@\h '
    fi

    if [ -n "${PROMPT_USER_PART}" ] || [ -n "${PROMPT_HOST_PART}" ]; then
        local OPTIONAL_SPACE=' '
    fi

    # Non-printing chars must be surrounded by \[ and \] to tell bash that
    # they don't take up any space.  Otherwise wrapping will be whacked.
    PS1="${FACE_PART}\[${PROMPT_COLOR}\][${PROMPT_USER_PART}${PROMPT_HOST_PART}${OPTIONAL_SPACE}\W]\[${COLOR_DEFAULT}\] "
}

# TODO if you su to a user who doesn't have this script, PROMPT_COMMAND is
# still set but promptcmd doesn't exist because it's not inherited across
# processes like an environment variable.  One solution would be to put the
# prompt command in someplace globally readable and put the full path to that
# in. Not sure how this works across networks. Probably they would overwrite
# the prompt. Ideally, though, the prompt command would actually be embedded
# in the environment variables so that it could actually get passed down.  I
# think this can be done but it's super ugly.
